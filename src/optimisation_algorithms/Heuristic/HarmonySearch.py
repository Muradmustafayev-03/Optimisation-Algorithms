from typing import Tuple
import numpy as np


class HarmonySearch:
    """
    Harmony Search optimization algorithm.

    Parameters:
    ----------
    - f : callable
        The objective function to be optimized.
    - d : int
        The dimensionality of the decision variables.
    - hm_size : int (default=30)
        The number of harmonies in the harmony memory.
    - hmcr : float (default=0.8)
        The harmony memory considering rate.
    - par : float (default=0.4)
        The pitch adjustment rate.
    - bandwidth : float (default=1)
        The bandwidth for pitch adjustment.
    - top_n : int (default=1)
        The number of best harmony solutions to consider for replacement.
    - tol : float (default=1e-8)
        The convergence threshold.
    - patience : int (default=10)
        The number of iterations to wait for improvement before stopping the optimization.
    - max_iter : int (default=10 ** 5)
        The maximum number of iterations to run.
    - rand_min : float (default=0)
        The minimum value for random initialization of decision variables.
    - rand_max : float (default=1)
        The maximum value for random initialization of decision variables.

    Methods:
    --------
    - eval(hm: np.ndarray) -> np.ndarray:
        Evaluates the objective function at each point in the harmony memory.
    - improvise(hm: np.ndarray) -> np.ndarray:
        Generates a new harmony by adjusting elements of the input harmony.
    - replace_worst_with_best(old_hm: np.ndarray, new_hm: np.ndarray, maximize: bool = False) -> np.ndarray:
        Replaces the worst solutions in the harmony memory with the best solutions.
    - fit(maximize: bool = False) -> Tuple[np.ndarray, float]:
        Finds the optimal solution for the given objective function.
    """
    def __init__(self, f: callable, d: int, hm_size: int = 30, hmcr: float = 0.8, par: float = 0.4,
                 bandwidth: float = 1, top_n: int = 1, tol: float = 1e-8, patience: int = 10,
                 max_iter: int = 10 ** 5, rand_min: float = 0, rand_max: float = 1):
        self.f = f
        self.d = d
        self.hms = hm_size
        self.hmcr = hmcr
        self.par = par
        self.bw = bandwidth
        self.top_n = top_n
        self.tol = tol
        self.patience = patience
        self.max_iter = max_iter
        self.rand_min = rand_min
        self.rand_max = rand_max

    def eval(self, hm: np.array) -> np.ndarray:
        """
        Evaluates the harmony memories in the harmony memory.

        Parameters:
        ----------
        - hm : numpy.ndarray
            An array representing the harmony memory (HM) to evaluate.

        Returns:
        -------
        - numpy.ndarray:
             An array representing the results of evaluating each solution in the harmony memory.
        """
        return np.vectorize(self.f)(*hm.T)

    def improvise(self, hm: np.array) -> np.ndarray:
        """
        Generates a new harmony by improvising and adjusting the existing harmony.

        Parameters:
        ----------
        - hm : numpy.ndarray
            A numpy array representing the current harmony to improvise.

        Returns:
        -------
        - numpy.ndarray:
            A numpy array representing the new harmony generated by improvisation.
        """

        new_hm = hm.copy()

        # Replace the elements to adjust with new random values
        adjust_mask = np.random.rand(*new_hm.shape) > self.hmcr
        new_hm[adjust_mask] = np.random.uniform(self.rand_min, self.rand_max, adjust_mask.sum())

        # Apply the adjustments to the elements in the mutation mask
        adjust_amounts = np.random.uniform(-self.bw, self.bw, size=new_hm.shape)
        mutate_mask = np.random.rand(*new_hm.shape) > self.par
        new_hm[mutate_mask] += adjust_amounts[mutate_mask]

        return new_hm

    def replace_worst_with_best(self, old_hm: np.array, new_hm: np.array, maximize: bool = False) -> np.ndarray:
        """
        Replaces the worst solutions in the old harmony memory with the best solutions in the new harmony memory.

        Parameters:
        ----------
        - old_hm : numpy.ndarray
            The old harmony memory.
        - new_hm : numpy.ndarray
            The new harmony memory.
        - maximize : bool, optional
            A boolean indicating whether the optimization problem is maximization or minimization. Defaults to False.

        Returns:
        -------
        - numpy.ndarray:
            The updated old harmony memory after replacing the worst solutions with the best solutions.
        """
        old_results = self.eval(old_hm)
        new_results = self.eval(new_hm)

        sign = -1 if maximize else 1

        sorted_indices = np.argsort(old_results)[::sign]
        best_indices = sorted_indices[:self.top_n]
        worst_indices = sorted_indices[-self.top_n:]

        # Replace the worst solutions with the best solutions
        replace_mask = sign * new_results[best_indices] < sign * old_results[worst_indices]
        old_hm[worst_indices[replace_mask]] = new_hm[best_indices[replace_mask]]

        return old_hm

    def fit(self, maximize: bool = False) -> Tuple[np.ndarray, float]:
        """
        Finds the minimum or maximum of a function f using Harmony Search algorithm.

        Parameters:
        ----------
        - maximize : bool (default: False)
            If True, the method will find the maximum of the function. Otherwise, the default is False, and the method
            will find the minimum of the function.
        Returns:
        -------
        - best_hm : numpy.ndarray
            An array representing the decision variables that optimize the objective function.
        - best_val : float
            The optimized function value.
        """
        hm = np.random.uniform(self.rand_min, self.rand_max, (self.hms, self.d))
        best_hm_idx = np.argmin(self.eval(hm)) if not maximize else np.argmax(self.eval(hm))
        best_hm = hm[best_hm_idx]
        best_val = self.f(best_hm)
        current_patience = self.patience

        for i in range(self.max_iter):
            new_hm = self.improvise(hm)
            hm = self.replace_worst_with_best(hm, new_hm, maximize)

            new_best_hm_idx = np.argmax(self.eval(hm)) if maximize else np.argmin(self.eval(hm))
            new_best_hm = hm[new_best_hm_idx]
            new_best_val = self.f(new_best_hm)

            if abs(new_best_val - best_val) < self.tol:
                current_patience -= 1
                if current_patience == 0:
                    break
            else:
                current_patience = self.patience
                best_hm = new_best_hm
                best_val = new_best_val

        return best_hm, best_val
